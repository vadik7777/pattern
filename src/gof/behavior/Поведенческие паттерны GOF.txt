Поведенчиские паттерны GOF
1. Интерпритатор (Interpreter)
2. Итератор (Iterator) или Курсор (Cursor)
3. Команда (Command), Действие (Action) или Транзакция (Transaction)
4. Наблюдатель (Observer), Опубликовать - подписаться (Publish - Subscriber) или Delegation Event Model
5. Посетитель (Visitor)
6. Посредник (Mediator)
7. Состояние (State)
8. Стратегия (Strategy)
9. Цепочка обязанностей (Chain of Responsibility)
10. Хранитель (Memento)
11. Шаблонный метод (Template Method)

--> Итератор
Проблема
    Составной объект, например, список, должен предоставлять доступ к своим
    элементам (объектам), не раскрывая их внутреннюю структуру, причем
    перебирать список требуется по разному в зависимости от задачи
Решение
    Создается класс "Итератор" который определяет интерфейс для доступа и перебора
    элементов. "Конкретный Итератор" реализует интерфейс класса "Итератор" и следит
    за текущей позицией при обходе "Агрегата".
    "Агрегат" определяет интерфейс для создания объекта итератора.
    "Конкретный Агрегат" реализует интерфейс создания итератора и возвращает
    экземпляр класса "Конкретный Итератор" отслеживает текущий объект
    в агрегате и может вычислить следующий объект при переборе.

--> Команда (Command), Действие (Action) или Транзакция (Transaction)
Проблема
    Необходимо послать объекту запрос, не зная о том, выполнение
    какой операции запрошено и кто будет получателем.
Решение
    Инкапсулировать запрос как объект.
    "Клиент" создает объект "КонкретнаяКоманда", который вызывает операции
    получателя для выполнения запроса. "Инициатор" отправляет запрос,
    выполняя операцию "Команды" Выполнить().
    "Команда" объявляет интерфейс для выполнения операции "КонкретнаяКоманда",
    определяет связь между объектом "Получатель" и операцией Действие(), и,
    кроме того, реализует операцию Выполнить() путем вызова соотвествующих операций
    объекта "Получатель".
    "Клиент" создает экземпляр класса "КонкретнаяКоманда" и устанавливает его
    получателя, "Инициатор" обращается к команде для выполнения запроса,
    "Получатель" (любой класс) располагает информацией о способах выполнения
    операций, необходимых для выполнения запроса.

--> Наблюдатель (Observer). Опубликовать - подписаться (Publish - Subscribe) или Listener
Проблема
    Один объект ("Подписчик") должен знать об изменение состояний или некоторых
    событиях другого объекта. При этом необходимо поддерживать низкий уровень
    связывания с объектом - "Подписчиком".

Решение
    Определить интерфейс "Подписки". Объекты - подписчики реализуют этот интерфейс
    и динамически регистрируются для получения информации о некотором событии.
    Затем при реализации условленного события оповещаются все объекты - подписчики.

--> Посетитель (Visitor)
Проблема
    Над каждым объектом некоторой структуры выполняется операция. Определить новую
    операцию, не изменяя классы объектов.

Решение
    Класс "КонкретныйПосетитель" предоставляет контекст для этого алгоритма и сохраняет
    его локальное состояния.
    "Элемент" определяет операцию "Принять", которая принимает "Посетителя" в
    качестве аргумента, "КонкретныйЭлемент" реализует операцию "Принять", которая
    принимает "Посетителя" в качестве аргумента.
    "СтуктураОбъекта" может перечислить свои аргументы и предоставить посетителю
    высокоуровневый интерфейс для посещения своих элементов.

--> Состояние (State)
Проблема
    Варьировать поведение объекта в зависимости от его внутреннего состояния

Решение
    Класс "Контекст" делегирует зависящие от состояния запросы текущему объекту
    "КонкретноеСостояние" (хранит экземпляр подкласса "Конкретное состояние",
    которым определяется текущее состояние), и определяет интерфейс для клиентов.
    "КонкретноеСостояние" реализует поведение, ассоциированное с неким состоянием
    объекта "Контекст". "Состояние" определяет интерфейс для инкапсуляции поведения,
    ассоциированного с конкретным экземпляром "Контекста".

--> Стратегия (Strategy)
Проблема
    Спроектировать изменяемые, но надежные алгоритмы или стратегии.

Решение
    Определить для каждого алгоритма или стратегии отдельный класс со
    стандратным интерфейсом.

--> Цепочка обязанностей (Chain of Responsibility)
Проблема
    Запрос должен быть обработан несколькими объектами

Решение
    Логично использовать данный паттерн, если имеется более одного объекта,
    способного обработать запрос и обработчик заранее известен (и должен быть
    найден автоматически) или если весь набор объектов, которые способны обработать
    запрос, должен задаваться автоматически.



