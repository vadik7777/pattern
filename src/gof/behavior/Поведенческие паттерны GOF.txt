Поведенчиские паттерны GOF
1. Интерпритатор (Interpreter)
2. Итератор (Iterator) или Курсор (Cursor)
3. Команда (Command), Действие (Action) или Транзакция (Transaction)
4. Наблюдатель (Observer), Опубликовать - подписаться (Publish - Subscriber) или Delegation Event Model
5. Посетитель (Visitor)
6. Посредник (Mediator)
7. Состояние (State)
8. Стратегия (Strategy)
9. Цепочка обязанностей (Chain of Responsibility)
10. Шаблонный метод (Template Method)
11. Хранитель (Memento)

--> Интерпритатор
Проблема
    Имеется часто встречающаяся, подверженная изменениям задача.
Решение
    Создать интерпретатор, который решает данную задачу.

--> Итератор
Проблема
    Составной объект, например, список, должен предоставлять доступ к своим
    элементам (объектам), не раскрывая их внутреннюю структуру, причем
    перебирать список требуется по разному в зависимости от задачи
Решение
    Создается класс "Итератор" который определяет интерфейс для доступа и перебора
    элементов. "Конкретный Итератор" реализует интерфейс класса "Итератор" и следит
    за текущей позицией при обходе "Агрегата".
    "Агрегат" определяет интерфейс для создания объекта итератора.
    "Конкретный Агрегат" реализует интерфейс создания итератора и возвращает
    экземпляр класса "Конкретный Итератор" отслеживает текущий объект
    в агрегате и может вычислить следующий объект при переборе.

--> Команда (Command), Действие (Action) или Транзакция (Transaction)
Проблема
    Необходимо послать объекту запрос, не зная о том, выполнение
    какой операции запрошено и кто будет получателем.
Решение
    Инкапсулировать запрос как объект.
    "Клиент" создает объект "КонкретнаяКоманда", который вызывает операции
    получателя для выполнения запроса. "Инициатор" отправляет запрос,
    выполняя операцию "Команды" Выполнить().
    "Команда" объявляет интерфейс для выполнения операции "КонкретнаяКоманда",
    определяет связь между объектом "Получатель" и операцией Действие(), и,
    кроме того, реализует операцию Выполнить() путем вызова соотвествующих операций
    объекта "Получатель".
    "Клиент" создает экземпляр класса "КонкретнаяКоманда" и устанавливает его
    получателя, "Инициатор" обращается к команде для выполнения запроса,
    "Получатель" (любой класс) располагает информацией о способах выполнения
    операций, необходимых для выполнения запроса.

--> Наблюдатель (Observer). Опубликовать - подписаться (Publish - Subscribe) или Listener
Проблема
    Один объект ("Подписчик") должен знать об изменение состояний или некоторых
    событиях другого объекта. При этом необходимо поддерживать низкий уровень
    связывания с объектом - "Подписчиком".
Решение
    Определить интерфейс "Подписки". Объекты - подписчики реализуют этот интерфейс
    и динамически регистрируются для получения информации о некотором событии.
    Затем при реализации условленного события оповещаются все объекты - подписчики.

--> Посетитель (Visitor)
Проблема
    Над каждым объектом некоторой структуры выполняется операция. Определить новую
    операцию, не изменяя классы объектов.
Решение
    Класс "КонкретныйПосетитель" предоставляет контекст для этого алгоритма и сохраняет
    его локальное состояния.
    "Элемент" определяет операцию "Принять", которая принимает "Посетителя" в
    качестве аргумента, "КонкретныйЭлемент" реализует операцию "Принять", которая
    принимает "Посетителя" в качестве аргумента.
    "СтуктураОбъекта" может перечислить свои аргументы и предоставить посетителю
    высокоуровневый интерфейс для посещения своих элементов.

--> Состояние (State)
Проблема
    Варьировать поведение объекта в зависимости от его внутреннего состояния
Решение
    Класс "Контекст" делегирует зависящие от состояния запросы текущему объекту
    "КонкретноеСостояние" (хранит экземпляр подкласса "Конкретное состояние",
    которым определяется текущее состояние), и определяет интерфейс для клиентов.
    "КонкретноеСостояние" реализует поведение, ассоциированное с неким состоянием
    объекта "Контекст". "Состояние" определяет интерфейс для инкапсуляции поведения,
    ассоциированного с конкретным экземпляром "Контекста".

--> Стратегия (Strategy)
Проблема
    Спроектировать изменяемые, но надежные алгоритмы или стратегии.
Решение
    Определить для каждого алгоритма или стратегии отдельный класс со
    стандратным интерфейсом.

--> Цепочка обязанностей (Chain of Responsibility)
Проблема
    Запрос должен быть обработан несколькими объектами
Решение
    Логично использовать данный паттерн, если имеется более одного объекта,
    способного обработать запрос и обработчик заранее известен (и должен быть
    найден автоматически) или если весь набор объектов, которые способны обработать
    запрос, должен задаваться автоматически.

--> Шаблонный метод (Template Method)
Проблема
    Определить алгоритм и реализовать возможность переопределения некоторых
    шагов алгоритма для подклассов (без изменения общей структуры алгоритма)
Решение
    "Абстрактный класс" определяет абстрактные Операции(), замещаемые в
    конкретных подклассах для реализации шагов алгоритма, и реализует
    ШаблонныйМетод(), определяющий "скелет" алгоритма. "КонкретныйКласс"
    реализует Операции(), выполняющие шаг алгоритма способом, который
    зависит от подкласса.
    "КонкретныйКласс" предполагает, что инвариантные шаги алгоритма будут
    выполнены в "АбстрактномКлассе".

--> Хранитель (Memento)
Проблема
    Когда нужно сохранить состояние объекта для возможного последующего восстановления.
    Когда сохранение состояния должно проходить без нарушения принципа инкапсуляции.
Решение
    Классический вариант: Шаблон Хранитель используется двумя объектами: «Создателем» (originator)
    и «Опекуном» (caretaker). «Создатель» — это объект, у которого есть внутреннее состояние.
    Объект «Опекун» может производить некоторые действия с «Создателем»,
    но при этом необходимо иметь возможность откатить изменения.
    Для этого «Опекун» запрашивает у «Создателя» объект «Хранителя».
    Затем выполняет запланированное действие (или последовательность действий).
    Для выполнения отката «Создателя» к состоянию, которое предшествовало изменениям,
    «Опекун» возвращает объект «Хранителя» его «Создателю».
    «Хранитель» является непрозрачным (то есть таким, который не может или не должен изменяться «Опекуном»).


